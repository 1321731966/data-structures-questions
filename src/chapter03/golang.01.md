### 算法

算法是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。

* [一、算法介绍](#算法介绍)
* [二、算法分析](#算法分析)
    * [数学模型](#数学模型)
    * [注意事项](#注意事项)
    * [ThreeSum](#threesum)
    * [倍率实验](#倍率实验)
* [三、排序](#排序)
    * [选择排序](#选择排序)
    * [冒泡排序](#冒泡排序)
    * [插入排序](#插入排序)
    * [希尔排序](#希尔排序)
    * [归并排序](#归并排序)
    * [快速排序](#快速排序)
    * [堆排序](#堆排序)
    * [小结](#小结)
* [四、并查集](#并查集)
    * [Quick Find](#quick-find)
    * [Quick Union](#quick-union)
    * [加权 Quick Union](#加权-quick-union)
    * [路径压缩的加权 Quick Union](#路径压缩的加权-quick-union)
    * [比较](#比较)
* [五、栈和队列](#栈和队列)
    * [栈](#栈)
    * [队列](#队列)
* [六、符号表](#符号表)
    * [初级实现](#初级实现)
    * [二叉查找树](#二叉查找树)
    * [2-3 查找树](#2-3-查找树)
    * [红黑树](#红黑树)
    * [散列表](#散列表)
    * [小结](#小结)
* [七、其它](#其它)
    * [汉诺塔](#汉诺塔)
    * [哈夫曼编码](#哈夫曼编码)
* [八、算法练习](#算法练习)   
* [参考资料](#参考资料)


#### 算法介绍

算法是求解一个问题所需要的步骤所形成的解决方法，每一步包括一个或者多个操作。无论是现实生活中还是计算机中，解决同一个问题的方法可能有很多种，在这N多种算法中，肯定存在一个执行效率最快的方法，那么这个方法就是最优算法。

算法具有五个基本特征：输入、输出、有穷性、确定性和可行性。

1. 输入

一个算法具有零个或者多个输出。以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件。

2. 输出

算法至少有一个输出。也就是说，算法一定要有输出。输出的形式可以是打印，也可以使返回一个值或者多个值等。也可以是显示某些提示。

3. 有穷性

算法的执行步骤是有限的，算法的执行时间也是有限的。

4. 确定性

算法的每个步骤都有确定的含义，不会出现二义性。

5. 可行性

算法是可用的，也就是能够解决当前问题。

算法的设计要求:

1. 正确性

对于合法输入能够得到满足的结果,算法能够处理非法处理，并得到合理结果.算法对于边界数据和压力数据都能得到满足的结果。

2. 可读性

算法要方便阅读，理解和交流，只有自己能看得懂，其它人都看不懂，谈和好算法。

3. 健壮性

通俗的讲,一个好的算法应该具有捕获异常/处理异常的能力。另外，对于测试人员的压力测试、边界值测试等刁难的测试手段，算法应该能够轻松的扛过去。

4. 高性价比

利用最少的时间和资源得到满足要求的结果，可以通过(时间复杂度和空间复杂度来判定)。

通常判定一种算法的效率可以采用事后统计法和事前分析估算.

事后统计法缺点: 必须编写相应的测试程序，严重依赖硬件和运行时的环境，算法的数据采集相当的困难。

事前分析估算：　主要取决于问题的规模。

这里解释下时间复杂度和空间复杂度.

时间复杂度:

时间复杂度是对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。

公式： `T(n) = O( f(n) )` ,其中f(n)是问题规模n的函数，也就是执行某个操作的次数。

在没有特殊说明的情况下，我们所分析的时间复杂度都是指最坏的时间复杂度。


空间复杂度：

空间复杂度是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 


公式： S(n) = O( f(n) ),其中f(n)是在问题规模为n时所占用的内存空间大小。 

大O表示法同样也适合空间复杂度。


#### 常见算法
我们都知道，线性表分为无序线性表和有序线性表。 

无序线性表的数据并不是按升序或者降序来排列的，所以在插入和删除时，没有什么必须遵守的规矩而可以插入在数据尾部或者删除在数据尾部（将待删除的数据和最后一个数据交换位置），但是在查找的时候，需要遍历整个数据集，影响了效率。 
有序线性表的数据则想法，查找的时候因为数据有序，可以用二分法、插值法、斐波那契查找法来实现，但是，插入和删除需要维护有序的结构，会耗费大量的时间。 
为了提高插入和删除的效率，二叉排序树登场了。

1. 二叉搜索树 (Binary Search Tree)

* 所有非叶子结点至多拥有两个树（Left和Right）；
* 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
* 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
* 它的左、右子树也分别为二叉搜索树。

二叉搜索树种最关键的是的特点是，左子树结点一定比父结点小，右子树结点一定比父结点大 .




2. 平衡二叉查找树 ( Balanced Binary Search Tree )
3. 红黑树 (Red-Black Tree )
4. B~树/B+树 (B-Tree )

B/B+ 树就是N叉（N-ary）平衡树了，每个节点可以有更多的孩子，新的值可以插在已有的节点里，而不需要改变树的高度，从而大量减少重新平衡和数据迁移的次数，这非常适合做数据库索引这种需要持久化在磁盘，同时需要大量查询和插入操作的应用。



#### 算法练习

* 数组

1. 实现一个支持动态扩容的数组
2. 实现一个大小固定的有序数组，支持动态增删改操作
3. 实现两个有序数组合并为一个有序数组

* 链表

1. 实现单链表、循环链表、双向链表，支持增删操作
2. 实现单链表反转
3. 实现两个有序的链表合并为一个有序链表
4. 实现求链表的中间结点

* 栈

1. 用数组实现一个顺序栈
2. 用链表实现一个链式栈
3. 编程模拟实现一个浏览器的前进、后退功能

* 队列

1. 用数组实现一个顺序队列
2. 用链表实现一个链式队列
3. 实现一个循环队列

* 递归
1. 编程实现斐波那契数列求值f(n)=f(n-1)+f(n-2)
2. 编程实现求阶乘n!
3. 编程实现一组数据集合的全排列

* 排序

1. 实现归并排序、快速排序、插入排序、冒泡排序、选择排序
2. 编程实现O(n)时间复杂度内找到一组数据的第K大元素

* 二分查找

1. 实现一个有序数组的二分查找算法
2. 实现模糊二分查找算法（比如大于等于给定值的第一个元素）

* 散列表

1. 实现一个基于链表法解决冲突问题的散列表
2. 实现一个LRU缓存淘汰算法

* 字符串

1. 实现一个字符集，只包含a～z这26个英文字母的Trie树
2. 实现朴素的字符串匹配算法

* 二叉树

1. 实现一个二叉查找树，并且支持插入、删除、查找操作
2. 实现查找二叉查找树中某个节点的后继、前驱节点
3. 实现二叉树前、中、后序以及按层遍历

* 堆

1. 实现一个小顶堆、大顶堆、优先级队列
2. 实现堆排序
3. 利用优先级队列合并K个有序数组
4. 求一组动态数据集合的最大Top K

* 图

1. 实现有向图、无向图、有权图、无权图的邻接矩阵和邻接表表示方法
2. 实现图的深度优先搜索、广度优先搜索
3. 实现Dijkstra算法、A*算法
4. 实现拓扑排序的Kahn算法、DFS算法

* 回溯

1. 利用回溯算法求解八皇后问题
2. 利用回溯算法求解0-1背包问题

* 分治

1. 利用分治算法求一组数据的逆序对个数

* 动态规划

1. 0-1背包问题
2. 最小路径和
3. 编程实现莱文斯坦最短编辑距离
4. 编程实现查找两个字符串的最长公共子序列
5. 编程实现一个数据序列的最长递增子序列





#### 参考资料

* [Visualizations Algorithms](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)
* [Algorithms](https://algs4.cs.princeton.edu/home/)
